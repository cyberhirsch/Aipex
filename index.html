<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aipex - Generative AI Ranking</title>
    <link rel="stylesheet" href="style.css">
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-analytics.js";
        import { getDatabase, ref, onValue, get, update, push } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-database.js";

        // Firebase configuration (use your credentials)
        const firebaseConfig = {
            apiKey: "AIzaSyCrSS4lsxgSFA7SEtseW1KoiruQbUwR_xA",
            authDomain: "aipex-6d63b.firebaseapp.com",
            databaseURL: "https://aipex-6d63b-default-rtdb.europe-west1.firebasedatabase.app/",
            projectId: "aipex-6d63b",
            storageBucket: "aipex-6d63b.appspot.com",
            messagingSenderId: "356818143159",
            appId: "1:356818143159:web:49222b5a85629c4630ca32",
            measurementId: "G-D32Z47WHQ4"
        };


        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const analytics = getAnalytics(app);
        const db = getDatabase();

        // Main Script
        document.addEventListener('DOMContentLoaded', function () {
            let models = []; // Declare models array globally

            // Real-time database listener for models
            onValue(ref(db, 'models/'), (snapshot) => {
                try {
                    const modelsList = document.getElementById('modelsList');
                    modelsList.innerHTML = '';

                    if (!snapshot.exists()) {
                        modelsList.innerHTML = '<p>No models available yet.</p>';
                        return;
                    }

                    // Convert to array
                    models = [];
                    snapshot.forEach((childSnapshot) => {
                        models.push({
                            id: childSnapshot.key,
                            ...childSnapshot.val()
                        });
                    });

                    // Collect all unique tags
                    const allTagsSet = new Set();
                    models.forEach(model => {
                        if (model.tags && Array.isArray(model.tags)) {
                            model.tags.forEach(tag => allTagsSet.add(tag));
                        }
                    });
                    const allTags = Array.from(allTagsSet).sort();

                    // Display Tag Checkboxes
                    const tagsFilterContainer = document.getElementById('tagsFilterContainer');
                    tagsFilterContainer.innerHTML = ''; // Clear existing tags

                    allTags.forEach(tag => {
                        const tagElement = document.createElement('div');
                        tagElement.className = 'tag-filter';
                        tagElement.innerHTML = `
                            <input type="checkbox" id="tagFilter-${tag}" value="${tag}" class="tag-checkbox">
                            <label for="tagFilter-${tag}">${tag}</label>
                        `;
                        tagsFilterContainer.appendChild(tagElement);
                    });

                    // Add event listener to checkboxes
                    const tagCheckboxes = document.querySelectorAll('.tag-checkbox');
                    tagCheckboxes.forEach(checkbox => {
                        checkbox.addEventListener('change', applyTagFilters);
                    });

                    // Apply tag filters
                    applyTagFilters();

                } catch (error) {
                    console.error('Failed to load models:', error);
                    alert('Failed to load model rankings. Please try again later.');
                }
            });

            // Voting Function
            window.voteForModel = async function (modelId) {
                try {
                    // Check if the user has already voted for this model using local storage
                    const votedModels = JSON.parse(localStorage.getItem('votedModels')) || [];
                    if (votedModels.includes(modelId)) {
                        alert('You have already voted for this model.');
                        return;
                    }

                    // Proceed with voting logic
                    const modelRef = ref(db, `models/${modelId}`);
                    const snapshot = await get(modelRef);

                    if (!snapshot.exists()) {
                        throw new Error('Model not found');
                    }

                    const currentVotes = snapshot.val().votes;
                    await update(modelRef, {
                        votes: currentVotes + 1,
                        lastUpdated: new Date().toISOString()
                    });

                    // Store modelId in Local Storage to mark as voted
                    votedModels.push(modelId);
                    localStorage.setItem('votedModels', JSON.stringify(votedModels));

                    alert('Vote recorded!');
                } catch (error) {
                    console.error('Failed to record vote:', error);
                    alert('Failed to record vote. Please try again.');
                }
            };

            // Function to update Editor's Choice
            async function updateEditorChoice(modelId, isChecked) {
                try {
                    // Optionally, check if the user has admin privileges
                    const modelRef = ref(db, `models/${modelId}`);
                    await update(modelRef, {
                        editorChoice: isChecked,
                        lastUpdated: new Date().toISOString()
                    });
                    alert('Editor\'s Choice updated!');
                } catch (error) {
                    console.error('Failed to update Editor\'s Choice:', error);
                    alert('Failed to update Editor\'s Choice. Please try again.');
                }
            }

            // Add new model function
            document.getElementById('addModelForm').addEventListener('submit', async function (e) {
                e.preventDefault();
                try {
                    const modelName = document.getElementById('modelName').value.trim();
                    const modelCategory = document.getElementById('modelCategory').value;
                    const modelLicense = document.getElementById('modelLicense').value;
                    const modelWeblink = document.getElementById('modelWeblink').value.trim();

                    // New code to get tags
                    const modelTagsInput = document.getElementById('modelTags').value.trim();
                    const modelTags = modelTagsInput.split(',').map(tag => tag.trim()).filter(tag => tag);

                    if (!modelName || !modelCategory || !modelLicense || !modelWeblink || modelTags.length === 0) {
                        throw new Error('Please fill in all fields');
                    }

                    const timestamp = new Date().toISOString();
                    await push(ref(db, 'models/'), {
                        name: modelName,
                        category: modelCategory,
                        license: modelLicense,
                        weblink: modelWeblink,
                        votes: 0,
                        editorChoice: false,
                        tags: modelTags, // Add tags here
                        createdAt: timestamp,
                        lastUpdated: timestamp
                    });

                    document.getElementById('addModelForm').reset();
                    alert('Model added successfully!');
                } catch (error) {
                    console.error('Error adding model:', error);
                    alert('Error: Failed to add model. Please try again.');
                }
            });

            // Populate categories from database
            const modelCategorySelect = document.getElementById('modelCategory');
            onValue(ref(db, 'categories/'), (snapshot) => {
                modelCategorySelect.innerHTML = '<option value="" disabled selected>Select a category</option>';
                if (snapshot.exists()) {
                    snapshot.forEach((childSnapshot) => {
                        const category = childSnapshot.val();
                        const optionElement = document.createElement('option');
                        optionElement.value = category;
                        optionElement.textContent = category;
                        modelCategorySelect.appendChild(optionElement);
                    });
                }
            });

            // Add new category function
            document.getElementById('addCategoryForm').addEventListener('submit', async function (e) {
                e.preventDefault();
                try {
                    const categoryName = document.getElementById('categoryName').value.trim();
                    if (!categoryName) {
                        throw new Error('Please enter a category name');
                    }

                    await push(ref(db, 'categories/'), categoryName);
                    document.getElementById('addCategoryForm').reset();
                    alert('Category added successfully!');
                } catch (error) {
                    console.error('Error adding category:', error);
                    alert('Error: Failed to add category. Please try again.');
                }
            });

            // Function to apply tag filters
            function applyTagFilters() {
                // Get selected tags
                const selectedTags = Array.from(document.querySelectorAll('.tag-checkbox:checked')).map(cb => cb.value);

                // Update models display
                const modelsList = document.getElementById('modelsList');
                modelsList.innerHTML = '';

                if (models.length === 0) {
                    modelsList.innerHTML = '<p>No models available yet.</p>';
                    return;
                }

                // Group models by category
                const groupedModels = models.reduce((acc, model) => {
                    if (!acc[model.category]) acc[model.category] = [];
                    acc[model.category].push(model);
                    return acc;
                }, {});

                // Display models grouped by category
                Object.keys(groupedModels).forEach(category => {
                    const categoryModels = groupedModels[category];

                    // Filter models based on selected tags
                    const filteredModels = categoryModels.filter(model => {
                        if (selectedTags.length === 0) return true; // No tags selected, include all
                        return model.tags && model.tags.some(tag => selectedTags.includes(tag));
                    });

                    if (filteredModels.length === 0) {
                        // Skip categories with no models after filtering
                        return;
                    }

                    // Create category section
                    const categoryElement = document.createElement('div');
                    categoryElement.className = 'category-section';
                    categoryElement.innerHTML = `<h2>${category}</h2>`;

                    // Sort and display models
                    filteredModels.sort((a, b) => b.votes - a.votes);
                    filteredModels.forEach((model, index) => {
                        const modelElement = document.createElement('div');
                        modelElement.className = 'model-row';
                        modelElement.innerHTML = `
                            <span class="model-index">${index + 1}.</span>
                            <a href="${model.weblink}" target="_blank" class="model-name">${model.name}</a>
                            <span class="model-license">${model.license}</span>
                            <span class="model-votes">${model.votes} votes</span>
                            <span class="model-tags">Tags: ${model.tags.join(', ')}</span>
                            <button onclick="voteForModel('${model.id}')" class="vote-button">Vote</button>
                            <input type="checkbox" id="editorChoice-${model.id}" ${model.editorChoice ? 'checked' : ''}>
                            <label for="editorChoice-${model.id}">Editor's Choice</label>
                        `;
                        // Add event listener for Editor's Choice checkbox
                        setTimeout(() => {
                            const editorCheckbox = document.getElementById(`editorChoice-${model.id}`);
                            editorCheckbox.addEventListener('change', function(e) {
                                updateEditorChoice(model.id, e.target.checked);
                            });
                        }, 0);
                        categoryElement.appendChild(modelElement);
                    });

                    modelsList.appendChild(categoryElement);
                });
            }
        });
    </script>
</head>
<body>
    <header>
        <h1>Aipex Rankings - Top AI Models</h1>
    </header>
    <main>
        <!-- Tag Filters Section -->
        <section id="tagFilters">
            <h2>Filter by Tags</h2>
            <div id="tagsFilterContainer">
                <!-- Tag checkboxes will be populated here -->
            </div>
        </section>

        <!-- Ranking Section -->
        <section id="ranking">
            <div id="modelsList" class="models-grid">
                <!-- Top models will appear here in a compact format -->
            </div>
        </section>

        <!-- Add Model Section -->
        <section id="addModel">
            <h2>Add a New Model</h2>
            <form id="addModelForm">
                <div class="form-group">
                    <label for="modelName">Model Name:</label>
                    <input type="text" id="modelName" placeholder="e.g., GPT-4, DALL-E 3" required>
                </div>
                <div class="form-group">
                    <label for="modelCategory">Category:</label>
                    <select id="modelCategory" required>
                        <option value="" disabled selected>Select a category</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="modelLicense">License:</label>
                    <select id="modelLicense" required>
                        <option value="" disabled selected>Select a license type</option>
                        <option value="Open Source">Open Source</option>
                        <option value="Commercial">Commercial</option>
                        <option value="Freemium">Freemium</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="modelWeblink">Weblink:</label>
                    <input type="text" id="modelWeblink" placeholder="e.g., https://model-link.com" required>
                </div>
                <div class="form-group">
                    <label for="modelTags">Tags:</label>
                    <input type="text" id="modelTags" placeholder="e.g., NLP, Transformer, OpenAI" required>
                    <small>Enter tags separated by commas.</small>
                </div>
                <button type="submit">Add Model</button>
            </form>
        </section>

        <!-- Add Category Section -->
        <section id="addCategory">
            <h2>Add a New Category</h2>
            <form id="addCategoryForm">
                <div class="form-group">
                    <label for="categoryName">Category Name:</label>
                    <input type="text" id="categoryName" placeholder="e.g., NLP, Vision" required>
                </div>
                <button type="submit">Add Category</button>
            </form>
        </section>
    </main>
    <footer>
        <p>Updated: November 2024</p>
        <p>Aipex Version: v0.0.8</p>
        <a href="admin.html">Admin Page</a>
    </footer>
</body>
</html>
Updated CSS (style.css):
Make sure to include styles for the new elements, such as the tag filters and model tags.

css
Copy code
/* Existing styles */

/* Tag Filters */
#tagFilters {
    margin: 20px 0;
}

#tagsFilterContainer {
    display: flex;
    flex-wrap: wrap;
}

.tag-filter {
    display: inline-flex;
    align-items: center;
    margin-right: 10px;
    margin-bottom: 10px;
}

.tag-filter input {
    margin-right: 5px;
}

/* Model Tags */
.model-tags {
    display: block;
    margin-top: 5px;
    font-size: 0.9em;
    color: #555;
}

/* Adjust model-row to accommodate tags */
.model-row {
    margin-bottom: 20px;
}

/* Rest of your styles */
Firebase Database Rules (Optional):
Ensure your Firebase Realtime Database rules allow reading and writing of the new tags field.

json
Copy code
{
  "rules": {
    "models": {
      ".read": true,
      ".write": true,
      "$modelId": {
        ".validate": "newData.hasChildren(['name', 'category', 'license', 'weblink', 'votes', 'editorChoice', 'tags', 'createdAt', 'lastUpdated'])"
      }
    },
    "categories": {
      ".read": true,
      ".write": true
    }
  }
}
